/*  Evaluate the results of "ProgramGenerator pident"
 *  @(#) $Id: IdentityEvaluator.java 808 2011-09-20 16:56:14Z gfis $
 *  2016-07-25: Georg Fischer: copied from ProgramGenerator
 */
/*
 * Copyright 2016 Dr. Georg Fischer <punctum at punctum dot kom>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.teherba.ramath;
import  org.teherba.ramath.ProgramGenerator;
import  org.teherba.ramath.linear.Matrix;
import  org.teherba.ramath.linear.Vector;
import  org.teherba.ramath.symbolic.Monomial;
import  org.teherba.ramath.symbolic.PolyMatrix;
import  org.teherba.ramath.symbolic.PolyVector;
import  org.teherba.ramath.symbolic.Polynomial;
import  org.teherba.ramath.symbolic.RelationSet;
import  org.teherba.ramath.symbolic.VariableMap;
import  org.teherba.ramath.util.ExpressionReader;
import  org.teherba.ramath.util.IntegerExpander;
import  org.teherba.ramath.util.MonotoneExpander;
import  java.io.BufferedReader;
import  java.io.File;
import  java.io.FileReader;
import  java.io.InputStreamReader;
import  java.io.PrintStream;
import  java.text.SimpleDateFormat;
import  java.util.Date;
import  java.util.LinkedHashMap;
import  java.util.Iterator;
import  java.util.regex.Pattern;
import  org.apache.log4j.Logger;

/** Reads the output lines of <em>progen.c</em> which was generated by, for example,
 *  <pre>
 java -cp dist/ramath.jar org.teherba.ramath.ProgramGenerator  -l 2 -f test/PG23.data.tmp pident
 *  </pre>
 *  Lines starting with {@link ProgramGenerator#LEADER} contain information
 *  about the {@link RelationSet} which defines the parametrization of
 *  th powersum, and the corresponding identity.
 *  @author Dr. Georg Fischer
 */
public class IdentityEvaluator {
    public final static String CVSID = "@(#) $Id: IdentityEvaluator.java 808 2011-09-20 16:56:14Z gfis $";

    /** Local logger for exceptions */
    private static Logger log = Logger.getLogger(IdentityEvaluator.class.getName());

    /** Debugging switch: 0 = no, 1 = moderate, 2 = more, 3 = extreme verbosity */
    public static int debug = 0;
    /** System dependant newline character sequence */
    protected static String newline = System.getProperty("line.separator");

    /** expand parameter variables up to and below this value */
    public int limit;
    /** number of rows of the generated matrix */
    public int nrows;
    /** number of columns of the generated matrix */
    public int ncols;
    /** {@link PolyMatrix} for names of coefficients */
    public PolyMatrix pmat;
    /** original {@link RelationSet} with isolated variables, parameters and coefficients */
    public RelationSet rset0;
    /** {@link VariableMap} for isolated variables in {@link #rset0} */
    public VariableMap vmiso;
    /** {@link VariableMap} for parameter variables in {@link #rset0} */
    public VariableMap vmpar;
    /** number of resulting /interesting output lines */
    public int reslines;
    /** String which identifies the start of a result line which contains significant information */
    public static final String LEADER = "#---> ";
    /** Generated program is written to this file */
    private PrintStream o;
    /** Stores the generated matrixes (as String keys).
     *  The values are TRUE if that matrix should be kept,
     *  or FALSE if the matrix was mappable to another by negating or exchanging rows.
     *  The inserting order should be maintained for reproducible test results.
     */
    public LinkedHashMap<String, String> matrices;

    //===========================
    // Construction
    //===========================
    /** No-args Constructor
     */
    public IdentityEvaluator() {
        o        = System.out;
        nrows    = 3;
        ncols    = 3;
        limit    = 3;
        matrices = new LinkedHashMap<String, String>(256);
        reslines = 0;
    } // Constructor()

    /** Initializes common variables
     */
    private void initialize() {
    } // initialize

    /** Closes the output file
     */
    private void close() {
    	o.println(LEADER + "reslines=" + String.valueOf(reslines));
        o.close();
    } // initialize

    //===========================
    // Action methods
    //===========================

    /** Compresses the set of {@link #matrices}
     *  by marking those which are mappable to another matrix
     *  by negating or exchanging rows.
     */
    public void compress() {
        switch (nrows) {
            case 3:
                compress2();
                break;
            case 4:
                compress3();
                break;
            default:
                // do nothing
                break;
        } // switch nrows
    } // compress

    /** Removes the marker for a negated or permuted matrix
     *  @param key original matrix as String
     *  @param amat modified matrix
     */
    private void unmark(String key, Matrix amat) {
        String key2 = amat.toString(",");
        if (! key2.equals(key) && matrices.get(key2) != null) {
            matrices.put(key2, "");
        }
    } // unmark
         
    /** Compresses the set of {@link #matrices} for Euclid/Pythagoras powersum a^2 + b^2 = c^2
     *  by marking those which are mappable to another matrix
     *  by negated or exchanged rows.
     *  The first 2 rows can be exchanged, and all rows can be negated in any combination.
     */
    private void compress2() {
        Matrix amat = null;
        String key2 = null;
        Iterator<String> miter = matrices.keySet().iterator();
        while (miter.hasNext()) { // negating
            String key = miter.next();
            if (matrices.get(key).length() > 0) { // marked TRUE
                int mask = 0;
                while (mask < 8) {
                    amat = new Matrix(key);
                    amat.negateRows(mask);
                    unmark(key, amat);
                    amat.exchangeRows(0, 1); // b^2 + a^2 = c^2
                    unmark(key, amat);
                    mask ++;
                } // while mask
            } // if TRUE
        } // while negating
    } // compress2

    /** Compresses the set of {@link #matrices} for cubic powersum a^3 + b^3 + c^3 = d^3
     *  by marking those which are mappable to another matrix
     *  by negated or exchanged rows.
     *  The first 3 rows can be permuted, and all 4 rows can be negated simultanously.
     */
    private void compress3() {
        Matrix amat = null;
        String key2 = null;
        int mask = 0xf; // negate all 4 rows
        Iterator<String> 
        miter = matrices.keySet().iterator();
        while (miter.hasNext()) { // negating
            String key = miter.next();
            if (matrices.get(key).length() > 0) { // marked TRUE
                amat = new Matrix(key);  // a b c 
                amat.negateRows(mask);
                unmark(key, amat);
                amat.exchangeRows(0, 1); // b a c
                unmark(key, amat);
                amat.negateRows(mask);
                unmark(key, amat);
                amat.exchangeRows(1, 2); // b c a
                unmark(key, amat);
                amat.negateRows(mask);
                unmark(key, amat);
                amat.exchangeRows(2, 0); // a c b
                unmark(key, amat);
                amat.negateRows(mask);
                unmark(key, amat);
                amat.exchangeRows(0, 1); // c a b
                unmark(key, amat);
                amat.negateRows(mask);
                unmark(key, amat);
                amat.exchangeRows(1, 2); // c b a
                unmark(key, amat);
                amat.negateRows(mask);
                unmark(key, amat);
            } // if TRUE
        } // while negating

        miter = matrices.keySet().iterator();
        while (miter.hasNext()) { // negate and exchange c, d
            String key = miter.next();
            if (matrices.get(key).length() > 0) { // marked TRUE
                mask = 0xc; // negate rows 2,3
                amat = new Matrix(key);  // a b c d
                amat.exchangeRows(2, 3); // a b d c
                amat.negateRows(mask);   // a b -d -c
                unmark(key, amat);
            } // if TRUE
        } // while negate and exchange c,d

        miter = matrices.keySet().iterator();
        while (miter.hasNext()) { // exch a, d; exch b, c; neg b, c
            String key = miter.next();
            if (matrices.get(key).length() > 0) { // marked TRUE
                mask = 0x6; // negate rows 1, 2
                amat = new Matrix(key);  // a b c d
                amat.exchangeRows(0, 3); // d b d a
                amat.exchangeRows(1, 2); // d c b a
                amat.negateRows(mask);   // d -c -b a
                unmark(key, amat);
            } // if TRUE
        } // while exch a, d; exch b, c; neg b, c

        miter = matrices.keySet().iterator();
        while (miter.hasNext()) { // a b c d -> -b -a d c
            String key = miter.next();
            if (matrices.get(key).length() > 0) { // marked TRUE
                mask = 0x3; // negate rows 0, 1
                amat = new Matrix(key);  // a b c d
                amat.exchangeRows(2, 3); // a b d c
                amat.exchangeRows(0, 1); // b a d c
                amat.negateRows(mask);   // -b -a d c
                unmark(key, amat);
            } // if TRUE
        } // while exch a, d; exch b, c; neg b, c

    } // compress3

    /** Stores one generated matrix as String
     *  @param key String representation of the matrix
     */
    public void store(String key) {
        matrices.put(key, "TRUE");
    } // store

    /** Evaluates one result line in the output of <em>progen.c</em>.
     *  Tries to build a chain, and print it if possible.
     *  @param key {@link Matrix} in #String representation, with coefficient values
     */
    public void evaluate(String key) {
        Matrix amat = new Matrix(key);
        int agcd = amat.gcd();
        if (agcd > 1) {
            matrices.put(key, "gcd=" + String.valueOf(agcd));
        } else { // gcd == 1
            Vector vpsum = null;
            StringBuffer tuples = new StringBuffer(256);
            RelationSet rset1 = rset0.substitute(pmat.getVariableMap(amat)); // replace coefficients
            MonotoneExpander dispenser = new MonotoneExpander(vmpar.size(), limit);
            while (dispenser.hasNext()) {
                Vector vdisp = dispenser.getVector();
                if (vdisp.isMonotone() &&
                        vdisp.isCoprime()) {
                    vmpar.setValues(dispenser);
                    RelationSet rset2 = rset1.substitute(vmpar);
                    vpsum = rset2.getPowerSumVector();
                    if (true || vpsum.get(0) > 0 && vpsum.isMonotone()) {
                        tuples.append(/* dispenser.toString() + */ vpsum.toFactoredString() + " ");
                    }
                } // hasNoZero
                dispenser.next();
            } // while dispenser
            if (tuples.length() > 0) {
                String lastTuple = vpsum.toFactoredString().replaceAll("\\*\\d+", ""); // e.g. [4,3,5]
                String mark = ".";
                String result = tuples.toString().replaceAll(Pattern.quote(lastTuple), mark);
                int markPos  = result.indexOf(mark);
                int markPos2 = result.lastIndexOf(mark);
                if (markPos2 > markPos) { // there were at least 2 marks
                    result += "same=" + lastTuple;
                } else {
                	result = tuples.toString();
                	reslines ++;
                }
                matrices.put(key, result);
            }
        } // gcd == 1
    } // evaluate

    /** Evaluates all remaining matrices and
     *  tries to build a chain, and print it if possible.
     */
    public void evaluateChains() {
        Iterator<String> miter = matrices.keySet().iterator();
        while (miter.hasNext()) {
            String key = miter.next();
            if (matrices.get(key).length() > 0) { // is marked TRUE
                evaluate(key);
            }
        } // while miter
    } // evaluateChains

    /** Removes the unmarked matrices, and normalizes the remaining ones, 
     */
    public void normalize() {
        LinkedHashMap<String, String> temp = new LinkedHashMap<String, String>(64);
        Iterator<String> miter = matrices.keySet().iterator();
        while (miter.hasNext()) {
            String key   = miter.next();
            String value = matrices.get(key);
            if (value.length() > 0) { // is marked TRUE
                if (key.indexOf('-') >= 0) { // any negative sign
                    Matrix amat = new Matrix(key);
                    switch (nrows) {
                        case 3: // power 2 - negate individually
                            int irow = 0;
                            while (irow < nrows) {
                                Vector vecti = amat.getRow(irow);
                                if (vecti.isNegative()) { // all <= 0
                                    amat.setRow(irow, vecti.negate());
                                } // <= 0
                                irow ++;
                            } // while irow
                            break;
                        case 4:
                            if (amat.bias() < 0) { // more negative elements
                                amat.negateRows(0xf); // all 4
                            } // more negative
                            break;
                        default:
                            // do nothing
                            break;
                    } // switch nrows
                    key = amat.toString(",");
                } // any negative
                temp.put(key, value);
            } // marked TRUE
        } // while miter
        matrices = temp;
    } // normalize

    /** Shows all remaining matrices
     */
    public void show() {
        Iterator<String> miter = matrices.keySet().iterator();
        while (miter.hasNext()) {
            String key   = miter.next();
            String value = matrices.get(key);
            if (value.length() > 0) { // is marked TRUE
                o.println(key + "\t" + value);
            }
        } // while miter
    } // show

    //==========================
    // Main
    //==========================
    /** Test method.
     *  @param args commandline arguments:
     *  <ul>
     *  <li>-l limit for {@link MonotoneExpander}</li>
     *  <li>-f name of file with output from <em>progen.c</em></li>
     *  <li>-compr compress by removing negated and exchanged rows</li>
     *  <li>-chain try to expand a chain of result tuples</li>
     *  </ul>
     *  Tries a series of tuples with the generated matrixes.
     */
    public static void main(String[] args) {
        int iarg = 0;
        IdentityEvaluator ideval = new IdentityEvaluator();
        String action = "-chain";
        try {
            while (iarg < args.length) {
                String opt = args[iarg ++];
                if (false) {
                } else if (opt.equals    ("-l")) {
                    ideval.limit = Integer.parseInt(args[iarg ++]);

                } else if (opt.startsWith("-chain")) {
                    ideval.evaluateChains();

                } else if (opt.startsWith("-compr")) {
                    ideval.compress();
                    ideval.normalize();

                } else if (opt.equals    ("-f")) {
                    // read parameters and a list of generated matrices
                    String fileName = args[iarg ++];
                    BufferedReader testReader = null;
                    if (fileName.equals("-")) { // STDIN
                        testReader = new BufferedReader(new InputStreamReader(System.in, "UTF-8"));
                    } else {
                        File testCases = new File(fileName);
                        testReader = new BufferedReader(new FileReader(testCases));
                    } // not STDIN
                    String line = null;
                    while ((line = testReader.readLine()) != null) { // read and process lines
                        if (false) {
                        } else if (line.startsWith(ProgramGenerator.LEADER)) {
                            String rest = line.substring(ProgramGenerator.LEADER.length());
                            int eqPos = rest.indexOf('=');
                            if (eqPos >= 0) { // contains a parameter
                                String name  = rest.substring(0, eqPos).trim();
                                String value = rest.substring(eqPos + 1);
                                // System.out.println("name=\"" + name + "\", value=\"" + value + "\"");
                                if (false) {
                                } else if (name.startsWith("isol")) {
                                    ideval.vmiso = new VariableMap(value.split(","), "0");
                                } else if (name.startsWith("param")) {
                                    ideval.vmpar = new VariableMap(value.split(","), "0");
                                } else if (name.startsWith("nrows")) {
                                    ideval.nrows = Integer.parseInt(value);
                                } else if (name.startsWith("ncols")) {
                                    ideval.ncols = Integer.parseInt(value);
                                } else if (name.startsWith("pmat")) {
                                    ideval.pmat  = new PolyMatrix(value);
                                } else if (name.startsWith("rset")) {
                                    ideval.rset0 = RelationSet.parse(value);
                                }
                            } // contains '='
                        } else if (line.startsWith("[[")) {
                            // System.out.println("evaluate " + line);
                            int ccPos = line.indexOf("]]");
                            ideval.store(line.substring(0, ccPos + 2));
                        } // [[
                    } // while line
                } // opt -f

            } // while iarg
        } catch (Exception exc) {
            log.error(exc.getMessage(), exc);
        }
        ideval.show();
        ideval.close();
    } // main

} // IdentityEvaluator
