/*  Exhaustive generator for power identities
 *  @(#) $Id: ProgramGenerator.java 808 2011-09-20 16:56:14Z gfis $
 *  2016-04-22: Georg Fischer: copied from MatrixExhauster
 */
/*
 * Copyright 2016 Dr. Georg Fischer <punctum at punctum dot kom>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.teherba.ramath;
import  org.teherba.ramath.linear.Vector;
import  org.teherba.ramath.symbolic.Monomial;
import  org.teherba.ramath.symbolic.PolyMatrix;
import  org.teherba.ramath.symbolic.PolyVector;
import  org.teherba.ramath.symbolic.Polynomial;
import  org.teherba.ramath.symbolic.RelationSet;
import  org.teherba.ramath.symbolic.VariableMap;
import  java.io.PrintStream;
import  java.text.SimpleDateFormat;
import  java.util.Date;
import  java.util.Iterator;

/** Generates program code for exhaustion of matrices and formulas.
 *  The generated programs have minimal indenting or commenting 
 *  and they are meant to be compiled and executed 
 *  at once without further editing or parametrization.
 *  
 *  @author Dr. Georg Fischer
 */
public class ProgramGenerator {
    public final static String CVSID = "@(#) $Id: ProgramGenerator.java 808 2011-09-20 16:56:14Z gfis $";

    /** first digit used */
    public int minDigit;
    /** first digit not used for exhaustion by the expander: - minDigit + 1 */
    public int maxDigit;
    /** whether to generate non-zero entries only*/
    public boolean nonZero;
    /** code for programming language to be generated: C, Java, Perl */
    public String lang; 
    /** Generated program is written to this file */
    private PrintStream o;
    /** closing brackets for all opened <em>for</em> and <em>if</em> statements */
    private String brackets;
    /** size of the generated matrix */
    private int width;
    /** maximum exponent in formulae */
    private int exp;
    /** up to 3 {@link PolyVector}s */
    private PolyVector[] vects;
    /** up to 3 {@link Polynomial}s */
    private Polynomial[] polys;
    /** name of the method to be activated */
    private String method;

    //===========================
    // Construction
    //===========================
    /** No-args Constructor
     */
    public ProgramGenerator() {
        this("test/progen.c");
    } // Constructor()
    
    /** Constructor with output file name
     *  @param outfile name of output file
     */
    public ProgramGenerator(String outfile) {
        try {
            o        = new PrintStream(outfile, "UTF-8");
            lang     = "C";
            nonZero  = false;
            brackets = "";
            width    = 3;
            exp      = 2;
            method   = "m2comp";
            polys    = new Polynomial[3];
            vects    = new PolyVector[3];
        } catch (Exception exc) {
        }
    } // Constructor()
    
    /** Initializes common variables 
     */
    private void initialize() {
    } // initialize     

    /** Closes the output file
     */
    private void close() {
        o.close();
    } // initialize     

    //===========================
    // Common Utility Methods
    //===========================
    
    /** Generate a program header with the declartion of matrix elements
     *  @param width size of the matrix to be declared
     */
    private void programHeader(int width) {
        if (false) {
        } else if (lang.equals("C"   )) {
            o.println("/* Do   N O T   edit here! */");
            o.println("/* Generated by org.teherba.ramath.linear.ProgramGenerator on "
                    + (new SimpleDateFormat("yyyy-MM-dd' 'HH:mm")).format(new java.util.Date()) + " */");
            o.println("#include <stdio.h>");
            o.println("#include <stdlib.h>");
            o.println("int main(int argc, char *argv[]) {");
            o.println("int gcd2(int a, int b) {                              ");
            o.println("        int result = abs(a);                          ");
            o.println("        if (result > 1) {                             ");
            o.println("            int p = result; int q = abs(b);           ");
            o.println("            while (q != 0) {                          ");
            o.println("                int temp = q; q = p % q; p = temp;    ");
            o.println("            } /* while */                             ");
            o.println("            result = p;                               ");
            o.println("        } /* > 1 */                                   ");
            o.println("        if (result == 0) result = 1;                  ");
            o.println("        return abs(result);                           ");
            o.println("    } /* gcd2 */                                      ");
            o.println("int gcd3(int a, int b, int c) {                       ");
            o.println("        return gcd2(a, gcd2(b, c));                   ");
            o.println("    } /* gcd3 */                                      ");
            o.println("int gcd4(int a, int b, int c, int d) {                ");
            o.println("        return gcd2(a, gcd3(b, c, d));                ");
            o.println("    } /* gcd4 */                                      ");
            o.println("int gcd5(int a, int b, int c, int d, int e) {         ");
            o.println("        return gcd2(a, gcd4(b, c, d, e));             ");
            o.println("    } /* gcd5 */                                      ");

            // now print the variable declarations for the matrix elements
            String sep = "int ";
            for (int irow = 1; irow <= width; irow ++) {
                for (int icol = 1; icol <= width; icol ++) {
                    o.print(sep + "m" + String.valueOf(irow) + String.valueOf(icol));
                    sep = ",";
                } // for icol
                o.println();
            } // for irow 
            o.println(";");
            // C
        }
    } // programHeader
    
    /** Generate a program trailer
     */
    private void programTrailer() {
        if (false) {
        } else if (lang.equals("C"   )) {
            o.println(brackets); // all closing brackets opened by pubr()
            o.println("} /* main */");
            // C
        }
    } // programTrailer
    
    /** Open and push so 1 closing brackets
     */
    private void oc() {
        o.println(" {");
        brackets += "}";
    } // oc()

    /** Print <em>for</em> loops for 1 row
     *  @param irow row number
     */
    private void forRow(int irow) {
        for (int jcol = 1; jcol <= width; jcol ++) {
            String mij = "m" + String.valueOf(irow) + String.valueOf(jcol);
            o.print("for (" + mij + " = " + String.valueOf(minDigit) + "; " 
                    + mij + " < " + String.valueOf(maxDigit) + "; " 
                    + mij + "++) /* row " + String.valueOf(irow) + " */ "); oc();
            if (nonZero) {
                o.print("if (" + mij + " != 0)"); oc();
            } // nonZero
        } // for jcol
    } // forRow
    
    /** Print conditions which check whether 2 matrix rows are identical
     *  @param irow 1st row number
     *  @param jrow 2nd row number
     */
    private void checkSameRow(int irow, int jrow) {
        o.print("if ");
        String sep = "(";
        for (int kcol = 1; kcol <= width; kcol ++) {
            String mik = "m" + String.valueOf(irow) + String.valueOf(kcol);
            String mjk = "m" + String.valueOf(jrow) + String.valueOf(kcol);
            o.print(sep + mik + " != " + mjk);
            sep = " || ";
        } // for kcol
        o.print(") /* row " + String.valueOf(irow) + " != row " + String.valueOf(jrow) + " */ "); oc();
    } // checkSameRow
    
    /** Print conditions which check whether 2 matrix columns are identical
     *  @param icol 1st column number
     *  @param jcol 2nd column number
     */
    private void checkSameCol(int icol, int jcol) {
        o.print("if ");
        String sep = "(";
        for (int krow = 1; krow <= width; krow ++) {
            String mik = "m" + String.valueOf(krow) + String.valueOf(icol);
            String mjk = "m" + String.valueOf(krow) + String.valueOf(jcol);
            o.print(sep + mik + " != " + mjk);
            sep = " || ";
        } // for krow
        o.print(") /* col " + String.valueOf(icol) + " != col " + String.valueOf(jcol) + " */ "); oc();
    } // checkSameCol
    
    /** Print a row of the matrix in Vector form [m11,m12,m13]
     *  @param irow row number
     */
    private void printRow(int irow) {
        o.print("printf(\"");
        String sep = "[";
        for (int kcol = 1; kcol <= width; kcol ++) {
            o.print(sep + "%d");
            sep = ",";
        } // for kcol
        o.print("]\"");
        for (int kcol = 1; kcol <= width; kcol ++) {
            o.print(sep + "m" + String.valueOf(irow) + String.valueOf(kcol));
            sep = ",";
        } // for kcol
        o.println(");");
    } // printRow
 
    /** Print a matrix in vectorized form [[m11,m12],[m21,m22]]
     */
    private void printMatrix() {
        String sep = "[";
        for (int irow = 1; irow <= width; irow ++) {
            o.println("printf(\"" + sep + "\");");
            printRow(irow);
            sep = ",";
        } // for kcol
        o.println("printf(\"]\");");
    } // printMatrix
   
    //===========================
    // Generating Methods
    //===========================

    /** Generate n x n matrixes which preserve generated tuples
     *  @param vectg generating vector of {@link Polynomial}s,
     *  for example [[a^2-b^2],[2*a*b],[a^2+b^2]] for Pythagoras
     *  @param vectc vector of constants fulfilling the equality of <em>poly0</em>,
     *  for example [3,4,5]
     *  The element order must correspond to that of <em>vectg</em>
     *  @param poly0 Polynomial which represents the generator,
     *  for example p0^2 + q0^2 = r0^2. 
     *  The variable names in <em>poly0</em> must not overlap
     *  with those in <em>vectg</em>, and the lexicographical 
     *  order of the variable names in <em>poly0</em> should correspond 
     *  to the element order of <em>vectg</em>. 
     */
    public void m2opts(PolyVector vectg, PolyVector vectc, Polynomial poly0) {
        width = vectg.size();
        programHeader(width);
        PolyMatrix  pmat1 = new PolyMatrix(width, "m");
        PolyVector  vectm = pmat1.multiply(vectg);
        VariableMap vmap0 = poly0.getVariableMap();
        VariableMap vmap1 = new VariableMap(); // p1->0,q1->0,r1->0
        VariableMap vmap3 = new VariableMap(); // p->p1,q->q1,r->r1
        int 
        ivect = 0;  
        Iterator<String> viter = vmap0.keySet().iterator();
        while (viter.hasNext()) {
            String name  = viter.next();
            String value = vectm.get(ivect).toString();
            String name1 = name + "1";
            vmap0.put(name, value); 
            vmap1.put(name1, "0");
            vmap3.put(name, name1);
            o.print("int " + name + " = " + vectc.get(ivect).toString() + "; ");
            ivect ++;
        } // while viter
        o.println();
        Polynomial poly2  = poly0.substitute(vmap0);
        Monomial mono2    = new Monomial(vectg.getVariableMap().getNameArray());
        RelationSet rset1 = poly2.groupBy(mono2);       
        o.println("/*  vectg = " + vectg.toString());
        o.println("    vectc = " + vectc.toString());
        o.println("    poly0 = " + poly0.toString());
        o.println("    mono2 = " + mono2.toString());
        o.println("    rset1 = " + rset1.toList(true)); 
        o.println("*/");
        /* mono2= + a*b, rset1=
        [0]  + a^4*(m11^2 + 2*m11*m13 + m13^2 + m21^2 + 2*m21*m23 + m23^2 - m31^2 - 2*m31*m33 - m33^2)
        [1]  + 4*a^3*b*(m11*m12 + m12*m13 + m21*m22 + m22*m23 - m31*m32 - m32*m33)
        [2]  + 2*a^2*b^2*( - m11^2 + 2*m12^2 + m13^2 - m21^2 + 2*m22^2 + m23^2 + m31^2 - 2*m32^2 - m33^2)
        [3]  + 4*a*b^3*( - m11*m12 + m12*m13 - m21*m22 + m22*m23 + m31*m32 - m32*m33)
        [4]  + b^4*(m11^2 - 2*m11*m13 + m13^2 + m21^2 - 2*m21*m23 + m23^2 - m31^2 + 2*m31*m33 - m33^2) */

        String[] names0  = vmap0.getNameArray();
        PolyVector vect0 = new PolyVector(width, 0, names0);
        String[] names1  = vmap1.getNameArray();
        PolyVector vect1 = new PolyVector(width, 0, names1);
        for (int irow = 1; irow <= width; irow ++) {
            forRow(irow);
            for (int jrow = irow - 1; jrow >= 1; jrow --) { // avoid identical rows
                checkSameRow(irow, jrow);
            } // for jrow
            String v1 = names1[irow - 1];
            o.println("int " + v1 + " = " + pmat1.getRow(irow - 1).multiply(vect0).toString() + "; ");
            o.print("if (" + v1 + " > 0)"); oc();
        } // irow
        for (int icol = 1; icol <= width; icol ++) { // 1..3
            int jcol = 0;
            for (jcol = icol + 2; jcol <= width; jcol ++) { // 3..3; all except 1st must be ascending
                o.print("if (" + names1[jcol - 2] + " < " + names1[jcol - 1] + ") /* ascending */"); oc();
            } // for jcol
            for (jcol = icol + 1; jcol <= width; jcol ++) { // avoid identical colums
                checkSameCol(icol, jcol);
            } // for jcol
        } // icol    

        int irset = 0;
        while (irset < rset1.size()) {
            Polynomial polyr = rset1.get(irset);
            // o.print("if (" + polyr.toString() + " == 0) /* " + polyr.getFactor().toString() + " */"); oc();
            irset ++;
        } // while irset

        o.print("if ("); // skip if resulting tuple is the same 
        String 
        sep = "";
        ivect = 0;
        while (ivect < vmap1.size()) {
            o.print(sep + names1[ivect] + " != " + names0[ivect]);
            ivect ++;
            sep = " || ";
        } // while ivect
        o.print(") /* not same tuple */"); oc();

        Polynomial poly3 = poly0.substitute(vmap3);
        o.print("if (" + poly3.toString(5) + " == 0) /* chain 1 condition */"); oc(); // for vectc; 5: with noPower
        String nstr1 = vmap1.getNameString();
        o.println("int gcdnp = gcd" + width + "(" + nstr1 + ");");
        o.print  ("if (gcdnp == 1)"); oc();
        // o.println("    /* printf(\"\tnon-primitive/%d\", gcdnp); */");
        printMatrix();
        o.print("printf(\"\\tpreserves");
        ivect = 0;
        sep = "\\t[";
        while (ivect < vmap1.size()) {
            o.print(sep + "%d");
            ivect ++;
            sep = ",";
        } // while ivect
        o.println("]\"," + nstr1 + ");");

        o.println("int p2 = m11*p1 + m12*q1 + m13*r1;"); 
        o.println("int q2 = m21*p1 + m22*q1 + m23*r1;"); 
        o.println("int r2 = m31*p1 + m32*q1 + m33*r1;"); 
        o.println("if (p2*p2*p2 == q2*q2 + r2*r2) {");
        o.println("    printf(\"\\tchain2\");");
        o.println("}");
        o.println("printf(\"\\n\");");
        programTrailer();
    } // m2opts

    /** Generate 3x3 matrixes for composition triples
     */
    public void m2pyth() {
        programHeader(width);
        o.println("int a=3; int b=4; int c=5;");
        for (int irow = 1; irow <= width; irow ++) {
            forRow(irow);
            for (int jrow = irow - 1; jrow >= 1; jrow --) {
                checkSameRow(irow, jrow);
            } // for jrow
        } // irow
        for (int icol = 1; icol <= width; icol ++) {
            for (int jcol = icol + 1; jcol <= width; jcol ++) {
                checkSameCol(icol, jcol);
            } // for jcol
        } // icol

        // from PO1.this.tst:
        o.print("if (   m11^2 + 2*m11*m13 + m13^2 + m21^2 + 2*m21*m23 + m23^2 - m31^2 - 2*m31*m33 - m33^2 == 0)"); oc();
        o.print("if ( - m11^2 + 2*m12^2 + m13^2 - m21^2 + 2*m22^2 + m23^2 + m31^2 - 2*m32^2 - m33^2       == 0)"); oc();
        o.print("if (   m11*m12 + m12*m13 + m21*m22 + m22*m23 - m31*m32 - m32*m33                         == 0)"); oc();
        o.print("if ( - m11*m12 + m12*m13 - m21*m22 + m22*m23 + m31*m32 - m32*m33                         == 0)"); oc();
        o.print("int v1=m11*a+m12*b+m13*c; "); o.print("if (v1 > a           )"); oc();
        o.print("int v2=m21*a+m22*b+m23*c; "); o.print("if (v2 > b && v2 > v1)"); oc();
        o.print("int v3=m31*a+m32*b+m33*c; "); o.print("if (v3 > c && v3 > v2)"); oc();
        o.print("if (v1*v1 + v2*v2 - v3*v3 == 0)"); oc();
        printMatrix();
        o.println("printf(\"\tpreserves %d,%d,%d\\n\",v1,v2,v3);");
        programTrailer();
    } // m2pyth   

    //==========================================================

    /* Get the commandline parameters
     *  @param args command line arguments:
     *  <ul>
     *  <li>operation: m1, ...</li>
     *  <li>-e exponent</li>
     *  <li>-l maxDigit</li>
     *  <li>-n generate non-zero entries only</li>
     *  <li>-p poly: 1st, 2nd, 3rd Polynomial</li>
     *  <li>-v startVector</li>
     *  <li>-w width, matrix size</li>
     *  </ul>
     */
    private void getArguments(String[] args) {
        String op = "";
        int ipoly = -1;
        int ivect = -1;
        int iarg  = 0;
        while (iarg < args.length) { // get the arguments
            if (args[iarg].startsWith("-")) {
                op = args[iarg ++].substring(1).toLowerCase();
                if (false) {
                } else if (op.equals("e")) {
                    try {
                        exp   = Integer.parseInt(args[iarg ++]);
                    } catch (Exception exc) {
                    }
                } else if (op.equals("l")) {
                    int limit = 6;
                    try {
                        limit = Integer.parseInt(args[iarg ++]);
                    } catch (Exception exc) {
                    }
                    minDigit = - limit;                   
                    maxDigit = limit + 1;
                } else if (op.equals("n")) {
                    nonZero = true;
                } else if (op.equals("p")) {
                    ipoly ++;
                    polys[ipoly] = Polynomial.parse(args[iarg ++]);
                } else if (op.equals("v")) {
                    ivect ++; 
                    vects[ivect] = new PolyVector(args[iarg ++]);
                } else if (op.equals("w")) {
                    try {
                        width = Integer.parseInt(args[iarg ++]);
                    } catch (Exception exc) {
                    }
                } else {
                    System.err.println("unknown option \"-" + op + "\"");
                }
            } else {
                method = args[iarg ++];
            }
        } // while args
    } // getArguments
 
    //==========================
    // Main
    //==========================
    /** Test method.
     */
    public static void main(String[] args) {
        ProgramGenerator gen = new ProgramGenerator();
        gen.getArguments(args);
        //----------------------------------
        if (false) {
        } else if (gen.method.equals("m2opts" )) {
            gen.m2opts(gen.vects[0], gen.vects[1], gen.polys[0]);
        } else if (gen.method.equals("m2pyth" )) {
            gen.m2pyth();
        } else {
            System.err.println("unknown operation \"" + gen.method + "\"");
        }
        gen.close();
    } // main

} // ProgramGenerator
