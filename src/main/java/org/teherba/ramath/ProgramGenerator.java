/*  Exhaustive generator for power identities
 *  @(#) $Id: ProgramGenerator.java 808 2011-09-20 16:56:14Z gfis $
 *  2016-04-22: Georg Fischer: copied from MatrixExhauster
 */
/*
 * Copyright 2016 Dr. Georg Fischer <punctum at punctum dot kom>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.teherba.ramath;
import  org.teherba.ramath.linear.Vector;
import  org.teherba.ramath.symbolic.PolyMatrix;
import  org.teherba.ramath.symbolic.Polynomial;
import  java.io.PrintStream;
import  java.text.SimpleDateFormat;
import  java.util.Date;

/** Generates program code for exhaustion of matrices and formulas.
 *  The generated programs have minimal indenting or commenting 
 *  and they are meant to be compiled and executed 
 *  at once without further editing or parametrization.
 *  
 *  @author Dr. Georg Fischer
 */
public class ProgramGenerator {
    public final static String CVSID = "@(#) $Id: ProgramGenerator.java 808 2011-09-20 16:56:14Z gfis $";

    /** first digit used */
    public int minDigit;
    /** first digit not used for exhaustion by the expander: - minDigit + 1 */
    public int maxDigit;
    /** whether to generate non-zero entries only*/
    public boolean nonZero;
    /** code for programming language to be generated: C, Java, Perl */
    public String lang; 
    /** Copy of <em>System.out</em> */
    private static PrintStream o = System.out;
    /** closing brackets for all opened <em>for</em> and <em>if</em> statements */
    private String brackets;
    /** size of the generated matrix */
    private int width;

    //===========================
    // Construction
    //===========================
    /** No-args Constructor
     */
    public ProgramGenerator() {
        lang     = "C";
        nonZero  = false;
        brackets = "";
    } // Constructor()
    
    /** Initializes common variables 
     */
    private void initialize() {
    } // initialize     

    //===========================
    // Common Utility Methods
    //===========================
    
    /** Generate a program header with the declartion of matrix elements
     *  @param width size of the matrix to be declared
     */
    private void programHeader(int width) {
        if (false) {
        } else if (lang.equals("C"   )) {
            o.println("/* Do   N O T   edit here! */");
            o.println("/* Generated by org.teherba.ramath.linear.ProgramGenerator on "
                    + (new SimpleDateFormat("yyyy-MM-dd' 'HH:mm")).format(new java.util.Date()) + " */");
            o.println("#include <stdio.h>");
            o.println("int main(int argc, char *argv[]) {");

            // now print the variable declarations for the matrix elements
            String sep = "int ";
            for (int irow = 1; irow <= width; irow ++) {
                for (int icol = 1; icol <= width; icol ++) {
                    o.print(sep + "m" + String.valueOf(irow) + String.valueOf(icol));
                    sep = ",";
                } // for icol
                o.println();
            } // for irow 
            o.println(";");
            // C
        }
    } // programHeader
    
    /** Generate a program trailer
     */
    private void programTrailer() {
        if (false) {
        } else if (lang.equals("C"   )) {
            o.println(brackets); // all closing brackets opened by pubr()
            o.println("} /* main */");
            // C
        }
    } // programTrailer
    
    /** Open and push so 1 closing brackets
     */
    private void oc() {
        o.println(" {");
        brackets += "}";
    } // oc()

    /** Print <em>for</em> loops for 1 row
     *  @param irow row number
     */
    private void forRow(int irow) {
        for (int jcol = 1; jcol <= width; jcol ++) {
            String mij = "m" + String.valueOf(irow) + String.valueOf(jcol);
            o.print("for (" + mij + " = " + String.valueOf(minDigit) + "; " 
                    + mij + " < " + String.valueOf(maxDigit) + "; " 
                    + mij + "++)"); oc();
            if (nonZero) {
                o.print("if (" + mij + " != 0)"); oc();
            } // nonZero
        } // for jcol
    } // forRow
    
    /** Print conditions which check whether 2 matrix rows are identical
     *  @param irow 1st row number
     *  @param jrow 2nd row number
     */
    private void checkSameRow(int irow, int jrow) {
        o.print("if ");
        String sep = "(";
        for (int kcol = 1; kcol <= width; kcol ++) {
            String mik = "m" + String.valueOf(irow) + String.valueOf(kcol);
            String mjk = "m" + String.valueOf(jrow) + String.valueOf(kcol);
            o.print(sep + mik + " != " + mjk);
            sep = " || ";
        } // for kcol
        o.print(")"); oc();
    } // checkSameRow
    
    /** Print conditions which check whether 2 matrix columns are identical
     *  @param irow 1st row number
     *  @param jrow 2nd row number
     */
    private void checkSameCol(int icol, int jcol) {
        o.print("if ");
        String sep = "(";
        for (int krow = 1; krow <= width; krow ++) {
            String mik = "m" + String.valueOf(krow) + String.valueOf(icol);
            String mjk = "m" + String.valueOf(krow) + String.valueOf(jcol);
            o.print(sep + mik + " != " + mjk);
            sep = " || ";
        } // for krow
        o.print(")"); oc();
    } // checkSameCol
    
    /** Print a row of the matrix in Vector form [m11,m12,m13]
     *  @param irow row number
     */
    private void printRow(int irow) {
        o.print("printf(\"");
        String sep = "[";
        for (int kcol = 1; kcol <= width; kcol ++) {
            o.print(sep + "%d");
            sep = ",";
        } // for kcol
        o.print("]\"");
        for (int kcol = 1; kcol <= width; kcol ++) {
            o.print(sep + "m" + String.valueOf(irow) + String.valueOf(kcol));
            sep = ",";
        } // for kcol
        o.println(");");
    } // printRow
 
    /** Print a matrix in vectorized form [[m11,m12],[m21,m22]]
     */
    private void printMatrix() {
        String sep = "[";
        for (int irow = 1; irow <= width; irow ++) {
            o.println("printf(\"" + sep + "\");");
            printRow(irow);
            sep = ",";
        } // for kcol
        o.println("printf(\"]\");");
    } // printMatrix
   
    //===========================
    // Generating Methods
    //===========================

    //==========================================================

    /** Generate 3x3 matrixes for composition triples
     *  @param poly1 1st term in an output line of Sandbox.printCompositions()
     */
    public void m2comp(Polynomial poly1) {
        programHeader(width);
        o.println("int a=3; int b=4; int c=5;");
        for (int irow = 1; irow <= width; irow ++) {
            forRow(irow);
            for (int jrow = irow - 1; jrow >= 1; jrow --) {
                checkSameRow(irow, jrow);
            } // for jrow
        } // irow
        for (int icol = 1; icol <= width; icol ++) {
            for (int jcol = icol + 1; jcol <= width; jcol ++) {
                checkSameCol(icol, jcol);
            } // for jcol
        } // icol

        // from PO1.this.tst:
        o.print("if (   m11^2 + 2*m11*m13 + m13^2 + m21^2 + 2*m21*m23 + m23^2 - m31^2 - 2*m31*m33 - m33^2 == 0)"); oc();
        o.print("if ( - m11^2 + 2*m12^2 + m13^2 - m21^2 + 2*m22^2 + m23^2 + m31^2 - 2*m32^2 - m33^2       == 0)"); oc();
        o.print("if (   m11*m12 + m12*m13 + m21*m22 + m22*m23 - m31*m32 - m32*m33                         == 0)"); oc();
        o.print("if ( - m11*m12 + m12*m13 - m21*m22 + m22*m23 + m31*m32 - m32*m33                         == 0)"); oc();
        o.print("int v1=m11*a+m12*b+m13*c; "); o.print("if (v1 > a           )"); oc();
        o.print("int v2=m21*a+m22*b+m23*c; "); o.print("if (v2 > b && v2 > v1)"); oc();
        o.print("int v3=m31*a+m32*b+m33*c; "); o.print("if (v3 > c && v3 > v2)"); oc();
        o.print("if (v1*v1 + v2*v2 - v3*v3 == 0)"); oc();
        printMatrix();
        o.println("printf(\"\tpreserves %d,%d,%d\\n\",v1,v2,v3);");
        programTrailer();
    } // m2comp      

    //==========================
    // Main
    //==========================
    /** Test method.
     *  @param args command line arguments:
     *  <ul>
     *  <li>operation: m1, ...</li>
     *  <li>-e exponent</li>
     *  <li>-l maxDigit</li>
     *  <li>-n generate non-zero entries only</li>
     *  <li>-p poly: 1st, 2nd, 3rd Polynomial</li>
     *  <li>-v startVector</li>
     *  <li>-w width, matrix size</li>
     *  </ul>
     */
    public static void main(String[] args) {
        ProgramGenerator gen = new ProgramGenerator();
        String oper      = "m2"; // Tree of primitive Pythagorean triples
        String op        = "";
        int exp          = 2;
        gen.width        = 6;
        Vector vect0     = null;
        Polynomial poly[] = new Polynomial[3];
        int ipoly        = -1;
        int iarg  = 0;
        while (iarg < args.length) { // get the arguments
            if (args[iarg].startsWith("-")) {
                op = args[iarg ++].substring(1).toLowerCase();
                if (false) {
                } else if (op.equals("e")) {
                    try {
                        exp   = Integer.parseInt(args[iarg ++]);
                    } catch (Exception exc) {
                    }
                } else if (op.equals("l")) {
                    int limit = 6;
                    try {
                        limit = Integer.parseInt(args[iarg ++]);
                    } catch (Exception exc) {
                    }
                    gen.minDigit = - limit;                   
                    gen.maxDigit = limit + 1;
                } else if (op.equals("n")) {
                    gen.nonZero = true;
                } else if (op.equals("p")) {
                    ipoly ++;
                    poly[ipoly] = Polynomial.parse(args[iarg ++]);
                } else if (op.equals("v")) {
                    vect0 = new Vector(args[iarg ++]);
                } else if (op.equals("w")) {
                    try {
                        gen.width = Integer.parseInt(args[iarg ++]);
                    } catch (Exception exc) {
                    }
                } else {
                    System.err.println("unknown option \"-" + op + "\"");
                }
            } else {
                oper = args[iarg ++];
            }
        } // while args

        if (false) {
        } else if (oper.equals("m2comp" )) {
            gen.m2comp(poly[0]);
        } else {
            System.err.println("unknown operation \"" + oper + "\"");
        }
    } // main

} // ProgramGenerator
